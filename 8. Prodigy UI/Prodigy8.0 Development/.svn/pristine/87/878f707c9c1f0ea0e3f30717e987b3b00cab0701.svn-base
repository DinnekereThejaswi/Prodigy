import { Injectable, NgZone, Optional, NgModule, defineInjectable, inject } from '@angular/core';
import { from, fromEvent, interval, merge, of, Subject, timer } from 'rxjs';
import { bufferTime, distinctUntilChanged, filter, finalize, map, scan, switchMap, take, takeUntil, tap } from 'rxjs/operators';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import * as ɵngcc0 from '@angular/core';
class UserIdleConfig {
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * User's idle service.
 */
class UserIdleService {
    /**
     * @param {?} config
     * @param {?} _ngZone
     */
    constructor(config, _ngZone) {
        this._ngZone = _ngZone;
        this.timerStart$ = new Subject();
        this.idleDetected$ = new Subject();
        this.timeout$ = new Subject();
        /**
         * Idle value in milliseconds.
         * Default equals to 10 minutes.
         */
        this.idleMillisec = 600 * 1000;
        /**
         * Idle buffer wait time milliseconds to collect user action
         * Default equals to 1 Sec.
         */
        this.idleSensitivityMillisec = 1000;
        /**
         * Timeout value in seconds.
         * Default equals to 5 minutes.
         */
        this.timeout = 300;
        /**
         * Ping value in milliseconds.
         * Default equals to 2 minutes.
         */
        this.pingMillisec = 120 * 1000;
        if (config) {
            this.setConfig(config);
        }
    }
    /**
     * Start watching for user idle and setup timer and ping.
     * @return {?}
     */
    startWatching() {
        if (!this.activityEvents$) {
            this.activityEvents$ = merge(fromEvent(window, 'mousemove'), fromEvent(window, 'resize'), fromEvent(document, 'keydown'));
        }
        this.idle$ = from(this.activityEvents$);
        if (this.idleSubscription) {
            this.idleSubscription.unsubscribe();
        }
        // If any of user events is not active for idle-seconds when start timer.
        this.idleSubscription = this.idle$
            .pipe(bufferTime(this.idleSensitivityMillisec), // Starting point of detecting of user's inactivity
        filter(arr => !arr.length && !this.isIdleDetected && !this.isInactivityTimer), tap(() => {
            this.isIdleDetected = true;
            this.idleDetected$.next(true);
        }), switchMap(() => this._ngZone.runOutsideAngular(() => interval(1000).pipe(takeUntil(merge(this.activityEvents$, timer(this.idleMillisec).pipe(tap(() => {
            this.isInactivityTimer = true;
            this.timerStart$.next(true);
        })))), finalize(() => {
            this.isIdleDetected = false;
            this.idleDetected$.next(false);
        })))))
            .subscribe();
        this.setupTimer(this.timeout);
        this.setupPing(this.pingMillisec);
    }
    /**
     * @return {?}
     */
    stopWatching() {
        this.stopTimer();
        if (this.idleSubscription) {
            this.idleSubscription.unsubscribe();
        }
    }
    /**
     * @return {?}
     */
    stopTimer() {
        this.isInactivityTimer = false;
        this.timerStart$.next(false);
    }
    /**
     * @return {?}
     */
    resetTimer() {
        this.stopTimer();
        this.isTimeout = false;
    }
    /**
     * Return observable for timer's countdown number that emits after idle.
     * @return {?}
     */
    onTimerStart() {
        return this.timerStart$.pipe(distinctUntilChanged(), switchMap(start => (start ? this.timer$ : of(null))));
    }
    /**
     * Return observable for idle status changed
     * @return {?}
     */
    onIdleStatusChanged() {
        return this.idleDetected$.asObservable();
    }
    /**
     * Return observable for timeout is fired.
     * @return {?}
     */
    onTimeout() {
        return this.timeout$.pipe(filter(timeout => !!timeout), tap(() => (this.isTimeout = true)), map(() => true));
    }
    /**
     * @return {?}
     */
    getConfigValue() {
        return {
            idle: this.idleMillisec,
            idleSensitivity: this.idleSensitivityMillisec,
            timeout: this.timeout,
            ping: this.pingMillisec
        };
    }
    /**
     * Set config values.
     * @param {?} config
     * @return {?}
     */
    setConfigValues(config) {
        if (this.idleSubscription && !this.idleSubscription.closed) {
            console.error('Call stopWatching() before set config values');
            return;
        }
        this.setConfig(config);
    }
    /**
     * @private
     * @param {?} config
     * @return {?}
     */
    setConfig(config) {
        if (config.idle) {
            this.idleMillisec = config.idle * 1000;
        }
        if (config.ping) {
            this.pingMillisec = config.ping * 1000;
        }
        if (config.idleSensitivity) {
            this.idleSensitivityMillisec = config.idleSensitivity * 1000;
        }
        if (config.timeout) {
            this.timeout = config.timeout;
        }
    }
    /**
     * Set custom activity events
     *
     * @param {?} customEvents Example: merge(
     *   fromEvent(window, 'mousemove'),
     *   fromEvent(window, 'resize'),
     *   fromEvent(document, 'keydown'),
     *   fromEvent(document, 'touchstart'),
     *   fromEvent(document, 'touchend')
     * )
     * @return {?}
     */
    setCustomActivityEvents(customEvents) {
        if (this.idleSubscription && !this.idleSubscription.closed) {
            console.error('Call stopWatching() before set custom activity events');
            return;
        }
        this.activityEvents$ = customEvents;
    }
    /**
     * Setup timer.
     *
     * Counts every seconds and return n+1 and fire timeout for last count.
     * @protected
     * @param {?} timeout Timeout in seconds.
     * @return {?}
     */
    setupTimer(timeout) {
        this._ngZone.runOutsideAngular(() => {
            this.timer$ = interval(1000).pipe(take(timeout), map(() => 1), scan((acc, n) => acc + n), tap(count => {
                if (count === timeout) {
                    this.timeout$.next(true);
                }
            }));
        });
    }
    /**
     * Setup ping.
     *
     * Pings every ping-seconds only if is not timeout.
     * @protected
     * @param {?} pingMillisec
     * @return {?}
     */
    setupPing(pingMillisec) {
        this.ping$ = interval(pingMillisec).pipe(filter(() => !this.isTimeout));
    }
}
UserIdleService.ngInjectableDef = ɵngcc0.ɵɵdefineInjectable({ token: UserIdleService, factory: function UserIdleService_Factory(t) { return new (t || UserIdleService)(ɵngcc0.ɵɵinject(UserIdleConfig, 8), ɵngcc0.ɵɵinject(NgZone)); }, providedIn: 'root' });
/*@__PURE__*/ ɵngcc0.ɵsetClassMetadata(UserIdleService, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], function () { return [{ type: UserIdleConfig, decorators: [{
                type: Optional
            }] }, { type: NgZone }]; }, { constructor: [], _ngZone: [], timerStart$: [], idleDetected$: [], timeout$: [], idleMillisec: [], idleSensitivityMillisec: [], timeout: [], pingMillisec: [], startWatching: [], activityEvents$: [], idle$: [], idleSubscription: [], isIdleDetected: [], isInactivityTimer: [], stopWatching: [], stopTimer: [], resetTimer: [], isTimeout: [], onTimerStart: [], onIdleStatusChanged: [], onTimeout: [], getConfigValue: [], setConfigValues: [], setConfig: [], setCustomActivityEvents: [], setupTimer: [], timer$: [], setupPing: [], ping$: [] });
/** @nocollapse */
UserIdleService.ctorParameters = () => [
    { type: UserIdleConfig, decorators: [{ type: Optional }] },
    { type: NgZone }
];
/** @nocollapse */ UserIdleService.ngInjectableDef = defineInjectable({ factory: function UserIdleService_Factory() { return new UserIdleService(inject(UserIdleConfig, 8), inject(NgZone)); }, token: UserIdleService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class UserIdleModule {
    /**
     * @param {?} config
     * @return {?}
     */
    static forRoot(config) {
        return {
            ngModule: UserIdleModule,
            providers: [
                { provide: UserIdleConfig, useValue: config }
            ]
        };
    }
}
UserIdleModule.ngModuleDef = ɵngcc0.ɵɵdefineNgModule({ type: UserIdleModule });
/*@__PURE__*/ ɵngcc0.ɵsetClassMetadata(UserIdleModule, [{
        type: NgModule,
        args: [{
                imports: []
            }]
    }], null, null);
UserIdleModule.ngInjectorDef = ɵngcc0.ɵɵdefineInjector({ factory: function UserIdleModule_Factory(t) { return new (t || UserIdleModule)(); }, imports: [[]] });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { UserIdleService, UserIdleConfig, UserIdleModule };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkU6L01hZ25hV2ViLUFuZ3VsYXI4LjAvbm9kZV9tb2R1bGVzL2FuZ3VsYXItdXNlci1pZGxlL2Zlc20yMDE1L2FuZ3VsYXItdXNlci1pZGxlLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7QUFRQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0E4TUMsa2tCQUtDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0F5QkQsOEpBS0MiLCJmaWxlIjoiYW5ndWxhci11c2VyLWlkbGUuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJbmplY3RhYmxlLCBOZ1pvbmUsIE9wdGlvbmFsLCBOZ01vZHVsZSwgZGVmaW5lSW5qZWN0YWJsZSwgaW5qZWN0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBmcm9tLCBmcm9tRXZlbnQsIGludGVydmFsLCBtZXJnZSwgb2YsIFN1YmplY3QsIHRpbWVyIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBidWZmZXJUaW1lLCBkaXN0aW5jdFVudGlsQ2hhbmdlZCwgZmlsdGVyLCBmaW5hbGl6ZSwgbWFwLCBzY2FuLCBzd2l0Y2hNYXAsIHRha2UsIHRha2VVbnRpbCwgdGFwIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgYWRkZWQgYnkgdHNpY2tsZVxuICogQHN1cHByZXNzIHtjaGVja1R5cGVzLGV4dHJhUmVxdWlyZSxtaXNzaW5nUmV0dXJuLHVudXNlZFByaXZhdGVNZW1iZXJzLHVzZWxlc3NDb2RlfSBjaGVja2VkIGJ5IHRzY1xuICovXG5jbGFzcyBVc2VySWRsZUNvbmZpZyB7XG59XG5cbi8qKlxuICogQGZpbGVvdmVydmlldyBhZGRlZCBieSB0c2lja2xlXG4gKiBAc3VwcHJlc3Mge2NoZWNrVHlwZXMsZXh0cmFSZXF1aXJlLG1pc3NpbmdSZXR1cm4sdW51c2VkUHJpdmF0ZU1lbWJlcnMsdXNlbGVzc0NvZGV9IGNoZWNrZWQgYnkgdHNjXG4gKi9cbi8qKlxuICogVXNlcidzIGlkbGUgc2VydmljZS5cbiAqL1xuY2xhc3MgVXNlcklkbGVTZXJ2aWNlIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGNvbmZpZ1xuICAgICAqIEBwYXJhbSB7P30gX25nWm9uZVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZywgX25nWm9uZSkge1xuICAgICAgICB0aGlzLl9uZ1pvbmUgPSBfbmdab25lO1xuICAgICAgICB0aGlzLnRpbWVyU3RhcnQkID0gbmV3IFN1YmplY3QoKTtcbiAgICAgICAgdGhpcy5pZGxlRGV0ZWN0ZWQkID0gbmV3IFN1YmplY3QoKTtcbiAgICAgICAgdGhpcy50aW1lb3V0JCA9IG5ldyBTdWJqZWN0KCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZGxlIHZhbHVlIGluIG1pbGxpc2Vjb25kcy5cbiAgICAgICAgICogRGVmYXVsdCBlcXVhbHMgdG8gMTAgbWludXRlcy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaWRsZU1pbGxpc2VjID0gNjAwICogMTAwMDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIElkbGUgYnVmZmVyIHdhaXQgdGltZSBtaWxsaXNlY29uZHMgdG8gY29sbGVjdCB1c2VyIGFjdGlvblxuICAgICAgICAgKiBEZWZhdWx0IGVxdWFscyB0byAxIFNlYy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaWRsZVNlbnNpdGl2aXR5TWlsbGlzZWMgPSAxMDAwO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGltZW91dCB2YWx1ZSBpbiBzZWNvbmRzLlxuICAgICAgICAgKiBEZWZhdWx0IGVxdWFscyB0byA1IG1pbnV0ZXMuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnRpbWVvdXQgPSAzMDA7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQaW5nIHZhbHVlIGluIG1pbGxpc2Vjb25kcy5cbiAgICAgICAgICogRGVmYXVsdCBlcXVhbHMgdG8gMiBtaW51dGVzLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5waW5nTWlsbGlzZWMgPSAxMjAgKiAxMDAwO1xuICAgICAgICBpZiAoY29uZmlnKSB7XG4gICAgICAgICAgICB0aGlzLnNldENvbmZpZyhjb25maWcpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN0YXJ0IHdhdGNoaW5nIGZvciB1c2VyIGlkbGUgYW5kIHNldHVwIHRpbWVyIGFuZCBwaW5nLlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgc3RhcnRXYXRjaGluZygpIHtcbiAgICAgICAgaWYgKCF0aGlzLmFjdGl2aXR5RXZlbnRzJCkge1xuICAgICAgICAgICAgdGhpcy5hY3Rpdml0eUV2ZW50cyQgPSBtZXJnZShmcm9tRXZlbnQod2luZG93LCAnbW91c2Vtb3ZlJyksIGZyb21FdmVudCh3aW5kb3csICdyZXNpemUnKSwgZnJvbUV2ZW50KGRvY3VtZW50LCAna2V5ZG93bicpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmlkbGUkID0gZnJvbSh0aGlzLmFjdGl2aXR5RXZlbnRzJCk7XG4gICAgICAgIGlmICh0aGlzLmlkbGVTdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIHRoaXMuaWRsZVN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIGFueSBvZiB1c2VyIGV2ZW50cyBpcyBub3QgYWN0aXZlIGZvciBpZGxlLXNlY29uZHMgd2hlbiBzdGFydCB0aW1lci5cbiAgICAgICAgdGhpcy5pZGxlU3Vic2NyaXB0aW9uID0gdGhpcy5pZGxlJFxuICAgICAgICAgICAgLnBpcGUoYnVmZmVyVGltZSh0aGlzLmlkbGVTZW5zaXRpdml0eU1pbGxpc2VjKSwgLy8gU3RhcnRpbmcgcG9pbnQgb2YgZGV0ZWN0aW5nIG9mIHVzZXIncyBpbmFjdGl2aXR5XG4gICAgICAgIGZpbHRlcihhcnIgPT4gIWFyci5sZW5ndGggJiYgIXRoaXMuaXNJZGxlRGV0ZWN0ZWQgJiYgIXRoaXMuaXNJbmFjdGl2aXR5VGltZXIpLCB0YXAoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5pc0lkbGVEZXRlY3RlZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmlkbGVEZXRlY3RlZCQubmV4dCh0cnVlKTtcbiAgICAgICAgfSksIHN3aXRjaE1hcCgoKSA9PiB0aGlzLl9uZ1pvbmUucnVuT3V0c2lkZUFuZ3VsYXIoKCkgPT4gaW50ZXJ2YWwoMTAwMCkucGlwZSh0YWtlVW50aWwobWVyZ2UodGhpcy5hY3Rpdml0eUV2ZW50cyQsIHRpbWVyKHRoaXMuaWRsZU1pbGxpc2VjKS5waXBlKHRhcCgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmlzSW5hY3Rpdml0eVRpbWVyID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMudGltZXJTdGFydCQubmV4dCh0cnVlKTtcbiAgICAgICAgfSkpKSksIGZpbmFsaXplKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuaXNJZGxlRGV0ZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuaWRsZURldGVjdGVkJC5uZXh0KGZhbHNlKTtcbiAgICAgICAgfSkpKSkpXG4gICAgICAgICAgICAuc3Vic2NyaWJlKCk7XG4gICAgICAgIHRoaXMuc2V0dXBUaW1lcih0aGlzLnRpbWVvdXQpO1xuICAgICAgICB0aGlzLnNldHVwUGluZyh0aGlzLnBpbmdNaWxsaXNlYyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgc3RvcFdhdGNoaW5nKCkge1xuICAgICAgICB0aGlzLnN0b3BUaW1lcigpO1xuICAgICAgICBpZiAodGhpcy5pZGxlU3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLmlkbGVTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIHN0b3BUaW1lcigpIHtcbiAgICAgICAgdGhpcy5pc0luYWN0aXZpdHlUaW1lciA9IGZhbHNlO1xuICAgICAgICB0aGlzLnRpbWVyU3RhcnQkLm5leHQoZmFsc2UpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIHJlc2V0VGltZXIoKSB7XG4gICAgICAgIHRoaXMuc3RvcFRpbWVyKCk7XG4gICAgICAgIHRoaXMuaXNUaW1lb3V0ID0gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybiBvYnNlcnZhYmxlIGZvciB0aW1lcidzIGNvdW50ZG93biBudW1iZXIgdGhhdCBlbWl0cyBhZnRlciBpZGxlLlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgb25UaW1lclN0YXJ0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy50aW1lclN0YXJ0JC5waXBlKGRpc3RpbmN0VW50aWxDaGFuZ2VkKCksIHN3aXRjaE1hcChzdGFydCA9PiAoc3RhcnQgPyB0aGlzLnRpbWVyJCA6IG9mKG51bGwpKSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gb2JzZXJ2YWJsZSBmb3IgaWRsZSBzdGF0dXMgY2hhbmdlZFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgb25JZGxlU3RhdHVzQ2hhbmdlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaWRsZURldGVjdGVkJC5hc09ic2VydmFibGUoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJuIG9ic2VydmFibGUgZm9yIHRpbWVvdXQgaXMgZmlyZWQuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBvblRpbWVvdXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRpbWVvdXQkLnBpcGUoZmlsdGVyKHRpbWVvdXQgPT4gISF0aW1lb3V0KSwgdGFwKCgpID0+ICh0aGlzLmlzVGltZW91dCA9IHRydWUpKSwgbWFwKCgpID0+IHRydWUpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBnZXRDb25maWdWYWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGlkbGU6IHRoaXMuaWRsZU1pbGxpc2VjLFxuICAgICAgICAgICAgaWRsZVNlbnNpdGl2aXR5OiB0aGlzLmlkbGVTZW5zaXRpdml0eU1pbGxpc2VjLFxuICAgICAgICAgICAgdGltZW91dDogdGhpcy50aW1lb3V0LFxuICAgICAgICAgICAgcGluZzogdGhpcy5waW5nTWlsbGlzZWNcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IGNvbmZpZyB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHs/fSBjb25maWdcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIHNldENvbmZpZ1ZhbHVlcyhjb25maWcpIHtcbiAgICAgICAgaWYgKHRoaXMuaWRsZVN1YnNjcmlwdGlvbiAmJiAhdGhpcy5pZGxlU3Vic2NyaXB0aW9uLmNsb3NlZCkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignQ2FsbCBzdG9wV2F0Y2hpbmcoKSBiZWZvcmUgc2V0IGNvbmZpZyB2YWx1ZXMnKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNldENvbmZpZyhjb25maWcpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7P30gY29uZmlnXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBzZXRDb25maWcoY29uZmlnKSB7XG4gICAgICAgIGlmIChjb25maWcuaWRsZSkge1xuICAgICAgICAgICAgdGhpcy5pZGxlTWlsbGlzZWMgPSBjb25maWcuaWRsZSAqIDEwMDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbmZpZy5waW5nKSB7XG4gICAgICAgICAgICB0aGlzLnBpbmdNaWxsaXNlYyA9IGNvbmZpZy5waW5nICogMTAwMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29uZmlnLmlkbGVTZW5zaXRpdml0eSkge1xuICAgICAgICAgICAgdGhpcy5pZGxlU2Vuc2l0aXZpdHlNaWxsaXNlYyA9IGNvbmZpZy5pZGxlU2Vuc2l0aXZpdHkgKiAxMDAwO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb25maWcudGltZW91dCkge1xuICAgICAgICAgICAgdGhpcy50aW1lb3V0ID0gY29uZmlnLnRpbWVvdXQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IGN1c3RvbSBhY3Rpdml0eSBldmVudHNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7P30gY3VzdG9tRXZlbnRzIEV4YW1wbGU6IG1lcmdlKFxuICAgICAqICAgZnJvbUV2ZW50KHdpbmRvdywgJ21vdXNlbW92ZScpLFxuICAgICAqICAgZnJvbUV2ZW50KHdpbmRvdywgJ3Jlc2l6ZScpLFxuICAgICAqICAgZnJvbUV2ZW50KGRvY3VtZW50LCAna2V5ZG93bicpLFxuICAgICAqICAgZnJvbUV2ZW50KGRvY3VtZW50LCAndG91Y2hzdGFydCcpLFxuICAgICAqICAgZnJvbUV2ZW50KGRvY3VtZW50LCAndG91Y2hlbmQnKVxuICAgICAqIClcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIHNldEN1c3RvbUFjdGl2aXR5RXZlbnRzKGN1c3RvbUV2ZW50cykge1xuICAgICAgICBpZiAodGhpcy5pZGxlU3Vic2NyaXB0aW9uICYmICF0aGlzLmlkbGVTdWJzY3JpcHRpb24uY2xvc2VkKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdDYWxsIHN0b3BXYXRjaGluZygpIGJlZm9yZSBzZXQgY3VzdG9tIGFjdGl2aXR5IGV2ZW50cycpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYWN0aXZpdHlFdmVudHMkID0gY3VzdG9tRXZlbnRzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXR1cCB0aW1lci5cbiAgICAgKlxuICAgICAqIENvdW50cyBldmVyeSBzZWNvbmRzIGFuZCByZXR1cm4gbisxIGFuZCBmaXJlIHRpbWVvdXQgZm9yIGxhc3QgY291bnQuXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEBwYXJhbSB7P30gdGltZW91dCBUaW1lb3V0IGluIHNlY29uZHMuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBzZXR1cFRpbWVyKHRpbWVvdXQpIHtcbiAgICAgICAgdGhpcy5fbmdab25lLnJ1bk91dHNpZGVBbmd1bGFyKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMudGltZXIkID0gaW50ZXJ2YWwoMTAwMCkucGlwZSh0YWtlKHRpbWVvdXQpLCBtYXAoKCkgPT4gMSksIHNjYW4oKGFjYywgbikgPT4gYWNjICsgbiksIHRhcChjb3VudCA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGNvdW50ID09PSB0aW1lb3V0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudGltZW91dCQubmV4dCh0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXR1cCBwaW5nLlxuICAgICAqXG4gICAgICogUGluZ3MgZXZlcnkgcGluZy1zZWNvbmRzIG9ubHkgaWYgaXMgbm90IHRpbWVvdXQuXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEBwYXJhbSB7P30gcGluZ01pbGxpc2VjXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBzZXR1cFBpbmcocGluZ01pbGxpc2VjKSB7XG4gICAgICAgIHRoaXMucGluZyQgPSBpbnRlcnZhbChwaW5nTWlsbGlzZWMpLnBpcGUoZmlsdGVyKCgpID0+ICF0aGlzLmlzVGltZW91dCkpO1xuICAgIH1cbn1cblVzZXJJZGxlU2VydmljZS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogSW5qZWN0YWJsZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICBwcm92aWRlZEluOiAncm9vdCdcbiAgICAgICAgICAgIH0sXSB9LFxuXTtcbi8qKiBAbm9jb2xsYXBzZSAqL1xuVXNlcklkbGVTZXJ2aWNlLmN0b3JQYXJhbWV0ZXJzID0gKCkgPT4gW1xuICAgIHsgdHlwZTogVXNlcklkbGVDb25maWcsIGRlY29yYXRvcnM6IFt7IHR5cGU6IE9wdGlvbmFsIH1dIH0sXG4gICAgeyB0eXBlOiBOZ1pvbmUgfVxuXTtcbi8qKiBAbm9jb2xsYXBzZSAqLyBVc2VySWRsZVNlcnZpY2UubmdJbmplY3RhYmxlRGVmID0gZGVmaW5lSW5qZWN0YWJsZSh7IGZhY3Rvcnk6IGZ1bmN0aW9uIFVzZXJJZGxlU2VydmljZV9GYWN0b3J5KCkgeyByZXR1cm4gbmV3IFVzZXJJZGxlU2VydmljZShpbmplY3QoVXNlcklkbGVDb25maWcsIDgpLCBpbmplY3QoTmdab25lKSk7IH0sIHRva2VuOiBVc2VySWRsZVNlcnZpY2UsIHByb3ZpZGVkSW46IFwicm9vdFwiIH0pO1xuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgYWRkZWQgYnkgdHNpY2tsZVxuICogQHN1cHByZXNzIHtjaGVja1R5cGVzLGV4dHJhUmVxdWlyZSxtaXNzaW5nUmV0dXJuLHVudXNlZFByaXZhdGVNZW1iZXJzLHVzZWxlc3NDb2RlfSBjaGVja2VkIGJ5IHRzY1xuICovXG5jbGFzcyBVc2VySWRsZU1vZHVsZSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBjb25maWdcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIHN0YXRpYyBmb3JSb290KGNvbmZpZykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmdNb2R1bGU6IFVzZXJJZGxlTW9kdWxlLFxuICAgICAgICAgICAgcHJvdmlkZXJzOiBbXG4gICAgICAgICAgICAgICAgeyBwcm92aWRlOiBVc2VySWRsZUNvbmZpZywgdXNlVmFsdWU6IGNvbmZpZyB9XG4gICAgICAgICAgICBdXG4gICAgICAgIH07XG4gICAgfVxufVxuVXNlcklkbGVNb2R1bGUuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IE5nTW9kdWxlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgIGltcG9ydHM6IFtdXG4gICAgICAgICAgICB9LF0gfSxcbl07XG5cbi8qKlxuICogQGZpbGVvdmVydmlldyBhZGRlZCBieSB0c2lja2xlXG4gKiBAc3VwcHJlc3Mge2NoZWNrVHlwZXMsZXh0cmFSZXF1aXJlLG1pc3NpbmdSZXR1cm4sdW51c2VkUHJpdmF0ZU1lbWJlcnMsdXNlbGVzc0NvZGV9IGNoZWNrZWQgYnkgdHNjXG4gKi9cblxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IGFkZGVkIGJ5IHRzaWNrbGVcbiAqIEBzdXBwcmVzcyB7Y2hlY2tUeXBlcyxleHRyYVJlcXVpcmUsbWlzc2luZ1JldHVybix1bnVzZWRQcml2YXRlTWVtYmVycyx1c2VsZXNzQ29kZX0gY2hlY2tlZCBieSB0c2NcbiAqL1xuXG5leHBvcnQgeyBVc2VySWRsZVNlcnZpY2UsIFVzZXJJZGxlQ29uZmlnLCBVc2VySWRsZU1vZHVsZSB9O1xuIl19