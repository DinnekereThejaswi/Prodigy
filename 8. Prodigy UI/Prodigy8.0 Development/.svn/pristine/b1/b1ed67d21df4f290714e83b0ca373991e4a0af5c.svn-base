/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
import { Injectable } from "@angular/core";
import { codes, modifiers } from "./keys";
import { fromEvent, timer, Subject, throwError } from "rxjs";
import { map, filter, tap, debounce, catchError } from "rxjs/operators";
import { allPass, any, difference, identity, isFunction, isNill } from "./utils";
const /** @type {?} */ $$ngOnDestroy = Symbol("OnDestroy");
export class KeyboardShortcutsService {
    constructor() {
        /**
         * Parsed shortcuts
         * for each key create a predicate function
         */
        this._shortcuts = [];
        /**
         * Throttle the keypress event.
         */
        this.throttleTime = 0;
        this._pressed = new Subject();
        /**
         * Streams of pressed events, can be used instead or with a command.
         */
        this.pressed$ = this._pressed.asObservable();
        /**
         * Disable all keyboard shortcuts
         */
        this.disabled = false;
        this._ignored = ["INPUT", "TEXTAREA", "SELECT"];
        this.isAllowed = (shortcut) => {
            const /** @type {?} */ target = /** @type {?} */ (shortcut.event.target);
            if (target === shortcut.target) {
                return true;
            }
            if (shortcut.allowIn.length) {
                return !difference(this._ignored, shortcut.allowIn).includes(target.nodeName);
            }
            return !this._ignored.includes(target.nodeName);
        };
        this.mapEvent = event => this._shortcuts
            .map(shortcut => Object.assign({}, shortcut, {
            predicates: any(identity, shortcut.predicates.map((predicates) => allPass(predicates)(event))),
            event: event
        }))
            .filter(shortcut => shortcut.predicates)
            .reduce((acc, shortcut) => (acc.priority > shortcut.priority ? acc : shortcut), /** @type {?} */ ({
            priority: 0
        }));
        this.keydown$ = fromEvent(document, "keydown").pipe(filter(_ => !this.disabled), map(this.mapEvent), filter((shortcut) => !shortcut.target || shortcut.event.target === shortcut.target), filter((shortcut) => isFunction(shortcut.command)), filter(this.isAllowed), tap(shortcut => !shortcut.preventDefault || shortcut.event.preventDefault()), debounce(shortcut => timer(shortcut.throttleTime)), tap(shortcut => shortcut.command({ event: shortcut.event, key: shortcut.key })), tap(shortcut => this._pressed.next({ event: shortcut.event, key: shortcut.key })), catchError(error => throwError(error)));
        /**
         * transforms a shortcut to:
         * a predicate function
         */
        this.getKeys = (command) => command
            .map(key => key.trim())
            .filter(key => key !== "+")
            .map(key => {
            // for modifiers like control key
            // look for event['ctrlKey']
            // otherwise use the keyCode
            if (modifiers.hasOwnProperty(key)) {
                return event => !!event[modifiers[key]];
            }
            return event => codes[key]
                ? event.keyCode === codes[key] || event.key === key
                : event.keyCode === key.toUpperCase().charCodeAt(0);
        });
        this.subscription = this.keydown$.subscribe();
    }
    /**
     * @return {?}
     */
    get shortcuts() {
        return this._shortcuts;
    }
    /**
     * Remove subscription.
     * @return {?}
     */
    ngOnDestroy() {
        if (this.subscription) {
            this.subscription.unsubscribe();
        }
    }
    /**
     * Enable all keyboard shortcuts
     * @return {?}
     */
    enable() {
        this.disabled = false;
        return this;
    }
    /**
     * Disable all keyboard shortcuts
     * @return {?}
     */
    disable() {
        this.disabled = true;
        return this;
    }
    /**
     * Check if all keyboard shortcuts are disabled.
     * @return {?}
     */
    isDisabled() {
        return this.disabled;
    }
    /**
     * Add new shortcut/s
     * @param {?} shortcuts
     * @param {?=} instance
     * @return {?}
     */
    add(shortcuts, instance) {
        shortcuts = Array.isArray(shortcuts) ? shortcuts : [shortcuts];
        if (instance) {
            const [key] = [...shortcuts.map(shortcut => shortcut.key)];
            this.bindOnDestroy(instance, key);
        }
        this._shortcuts.push(...this.parseCommand(shortcuts));
        return this;
    }
    /**
     * bind to the component ngOnDestroy to remove related keys
     * when component is destroyed.
     * @param {?} instance - component to remove keys when ngOnDestroy is called.
     * @param {?} keys
     * @return {?}
     */
    bindOnDestroy(instance, keys) {
        if (instance.ngOnDestroy) {
            instance[$$ngOnDestroy] = instance.ngOnDestroy;
        }
        const /** @type {?} */ that = this;
        instance.ngOnDestroy = function () {
            const /** @type {?} */ onDestroy = instance[$$ngOnDestroy];
            if (onDestroy) {
                onDestroy.apply(this);
            }
            that.remove(keys);
        };
        return this;
    }
    /**
     * Remove a command based on key or array of keys.
     * can be used for cleanup.
     * @param {?} key
     * @return {?}
     */
    remove(key) {
        const /** @type {?} */ keys = Array.isArray(key) ? key : [key];
        this._shortcuts = this._shortcuts.filter(shortcut => {
            return !shortcut.key.find(sKey => {
                return keys.filter(k => k === sKey).length > 0;
            });
        });
        return this;
    }
    /**
     * Returns an observable of keyboard shortcut filtered by a specific key.
     * @param {?} key - the key to filter the observable by.
     * @return {?}
     */
    select(key) {
        return this.pressed$.pipe(filter(({ event, key: eventKeys }) => {
            return !!eventKeys.find(eventKey => eventKey === key);
        }));
    }
    /**
     * Parse each command using getKeys function
     * @param {?} command
     * @return {?}
     */
    parseCommand(command) {
        const /** @type {?} */ commands = Array.isArray(command) ? command : [command];
        return commands.map(command => {
            const /** @type {?} */ keys = Array.isArray(command.key) ? command.key : [command.key];
            const /** @type {?} */ priority = Math.max(...keys.map(key => key.split(" ").length));
            const /** @type {?} */ predicates = keys.map(key => this.getKeys(key.split(" ")));
            return /** @type {?} */ (Object.assign({}, command, { allowIn: command.allowIn || [], key: keys, throttle: isNill(command.throttleTime) ? this.throttleTime : command.throttleTime, priority: priority, predicates: predicates }));
        });
    }
}
KeyboardShortcutsService.decorators = [
    { type: Injectable },
];
/** @nocollapse */
KeyboardShortcutsService.ctorParameters = () => [];
function KeyboardShortcutsService_tsickle_Closure_declarations() {
    /**
     * Parsed shortcuts
     * for each key create a predicate function
     * @type {?}
     */
    KeyboardShortcutsService.prototype._shortcuts;
    /**
     * Throttle the keypress event.
     * @type {?}
     */
    KeyboardShortcutsService.prototype.throttleTime;
    /** @type {?} */
    KeyboardShortcutsService.prototype._pressed;
    /**
     * Streams of pressed events, can be used instead or with a command.
     * @type {?}
     */
    KeyboardShortcutsService.prototype.pressed$;
    /**
     * Disable all keyboard shortcuts
     * @type {?}
     */
    KeyboardShortcutsService.prototype.disabled;
    /** @type {?} */
    KeyboardShortcutsService.prototype._ignored;
    /**
     * Subscription for on destroy.
     * @type {?}
     */
    KeyboardShortcutsService.prototype.subscription;
    /** @type {?} */
    KeyboardShortcutsService.prototype.isAllowed;
    /** @type {?} */
    KeyboardShortcutsService.prototype.mapEvent;
    /** @type {?} */
    KeyboardShortcutsService.prototype.keydown$;
    /**
     * transforms a shortcut to:
     * a predicate function
     * @type {?}
     */
    KeyboardShortcutsService.prototype.getKeys;
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibmcta2V5Ym9hcmQtc2hvcnRjdXRzLnNlcnZpY2UuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9uZy1rZXlib2FyZC1zaG9ydGN1dHMvIiwic291cmNlcyI6WyJsaWIvbmcta2V5Ym9hcmQtc2hvcnRjdXRzLnNlcnZpY2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7OztBQUFBLE9BQU8sRUFBRSxVQUFVLEVBQWEsTUFBTSxlQUFlLENBQUM7QUFDdEQsT0FBTyxFQUFFLEtBQUssRUFBRSxTQUFTLEVBQUUsTUFBTSxRQUFRLENBQUM7QUFDMUMsT0FBTyxFQUFFLFNBQVMsRUFBZ0IsS0FBSyxFQUFFLE9BQU8sRUFBRSxVQUFVLEVBQWMsTUFBTSxNQUFNLENBQUM7QUFNdkYsT0FBTyxFQUFFLEdBQUcsRUFBRSxNQUFNLEVBQUUsR0FBRyxFQUFFLFFBQVEsRUFBRSxVQUFVLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUN4RSxPQUFPLEVBQUUsT0FBTyxFQUFFLEdBQUcsRUFBRSxVQUFVLEVBQUUsUUFBUSxFQUFFLFVBQVUsRUFBRSxNQUFNLEVBQUUsTUFBTSxTQUFTLENBQUM7QUFFakYsdUJBQU0sYUFBYSxHQUFHLE1BQU0sQ0FBQyxXQUFXLENBQUMsQ0FBQztBQUcxQyxNQUFNO0lBOEVGOzs7OzswQkF6RXVDLEVBQUU7Ozs7NEJBS2xCLENBQUM7d0JBRUwsSUFBSSxPQUFPLEVBQXVCOzs7O3dCQUtuQyxJQUFJLENBQUMsUUFBUSxDQUFDLFlBQVksRUFBRTs7Ozt3QkFLM0IsS0FBSzt3QkFFTCxDQUFDLE9BQU8sRUFBRSxVQUFVLEVBQUUsUUFBUSxDQUFDO3lCQU85QixDQUFDLFFBQXdCLEVBQUUsRUFBRTtZQUM3Qyx1QkFBTSxNQUFNLHFCQUFHLFFBQVEsQ0FBQyxLQUFLLENBQUMsTUFBcUIsQ0FBQSxDQUFDO1lBQ3BELEVBQUUsQ0FBQyxDQUFDLE1BQU0sS0FBSyxRQUFRLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQztnQkFDN0IsTUFBTSxDQUFDLElBQUksQ0FB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QUFDLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLENBQUM7WUFDdEUsdUJBQU0sUUFBUSxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDO1lBQ3JFLHVCQUFNLFVBQVUsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUNqRSxNQUFNLG1CQUFDLGtCQUNBLE9BQU8sSUFDVixPQUFPLEVBQUUsT0FBTyxDQUFDLE9BQU8sSUFBSSxFQUFFLEVBQzlCLEdBQUcsRUFBRSxJQUFJLEVBQ1QsUUFBUSxFQUFFLE1BQU0sQ0FBQyxPQUFPLENBQUMsWUFBWSxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxZQUFZLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxZQUFZLEVBQ2pGLFFBQVEsRUFBRSxRQUFRLEVBQ2xCLFVBQVUsRUFBRSxVQUFVLEdBQ1AsRUFBQztTQUN2QixDQUFDLENBQUM7Ozs7WUF4TlYsVUFBVSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEluamVjdGFibGUsIE9uRGVzdHJveSB9IGZyb20gXCJAYW5ndWxhci9jb3JlXCI7XG5pbXBvcnQgeyBjb2RlcywgbW9kaWZpZXJzIH0gZnJvbSBcIi4va2V5c1wiO1xuaW1wb3J0IHsgZnJvbUV2ZW50LCBTdWJzY3JpcHRpb24sIHRpbWVyLCBTdWJqZWN0LCB0aHJvd0Vycm9yLCBPYnNlcnZhYmxlIH0gZnJvbSBcInJ4anNcIjtcbmltcG9ydCB7XG4gICAgU2hvcnRjdXRFdmVudE91dHB1dCxcbiAgICBQYXJzZWRTaG9ydGN1dCxcbiAgICBTaG9ydGN1dElucHV0XG59IGZyb20gXCIuL25nLWtleWJvYXJkLXNob3J0Y3V0cy5pbnRlcmZhY2VzXCI7XG5pbXBvcnQgeyBtYXAsIGZpbHRlciwgdGFwLCBkZWJvdW5jZSwgY2F0Y2hFcnJvciB9IGZyb20gXCJyeGpzL29wZXJhdG9yc1wiO1xuaW1wb3J0IHsgYWxsUGFzcywgYW55LCBkaWZmZXJlbmNlLCBpZGVudGl0eSwgaXNGdW5jdGlvbiwgaXNOaWxsIH0gZnJvbSBcIi4vdXRpbHNcIjtcblxuY29uc3QgJCRuZ09uRGVzdHJveSA9IFN5bWJvbChcIk9uRGVzdHJveVwiKTtcblxuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIEtleWJvYXJkU2hvcnRjdXRzU2VydmljZSBpbXBsZW1lbnRzIE9uRGVzdHJveSB7XG4gICAgLyoqXG4gICAgICogUGFyc2VkIHNob3J0Y3V0c1xuICAgICAqIGZvciBlYWNoIGtleSBjcmVhdGUgYSBwcmVkaWNhdGUgZnVuY3Rpb25cbiAgICAgKi9cbiAgICBwcml2YXRlIF9zaG9ydGN1dHM6IFBhcnNlZFNob3J0Y3V0W10gPSBbXTtcblxuICAgIC8qKlxuICAgICAqIFRocm90dGxlIHRoZSBrZXlwcmVzcyBldmVudC5cbiAgICAgKi9cbiAgICBwcml2YXRlIHRocm90dGxlVGltZSA9IDA7XG5cbiAgICBwcml2YXRlIF9wcmVzc2VkID0gbmV3IFN1YmplY3Q8U2hvcnRjdXRFdmVudE91dHB1dD4oKTtcblxuICAgIC8qKlxuICAgICAqIFN0cmVhbXMgb2YgcHJlc3NlZCBldmVudHMsIGNhbiBiZSB1c2VkIGluc3RlYWQgb3Igd2l0aCBhIGNvbW1hbmQuXG4gICAgICovXG4gICAgcHVibGljIHByZXNzZWQkID0gdGhpcy5fcHJlc3NlZC5hc09ic2VydmFibGUoKTtcblxuICAgIC8qKlxuICAgICAqIERpc2FibGUgYWxsIGtleWJvYXJkIHNob3J0Y3V0c1xuICAgICAqL1xuICAgIHByaXZhdGUgZGlzYWJsZWQgPSBmYWxzZTtcblxuICAgIHByaXZhdGUgX2lnbm9yZWQgPSBbXCJJTlBVVFwiLCBcIlRFWFRBUkVBXCIsIFwiU0VMRUNUXCJdO1xuXG4gICAgLyoqXG4gICAgICogU3Vic2NyaXB0aW9uIGZvciBvbiBkZXN0cm95LlxuICAgICAqL1xuICAgIHByaXZhdGUgcmVhZG9ubHkgc3Vic2NyaXB0aW9uOiBTdWJzY3JpcHRpb247XG5cbiAgICBwcml2YXRlIGlzQWxsb3dlZCA9IChzaG9ydGN1dDogUGFyc2VkU2hvcnRjdXQpID0+IHtcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gc2hvcnRjdXQuZXZlbnQudGFyZ2V0IGFzIEhUTUxFbGVtZW50O1xuICAgICAgICBpZiAodGFyZ2V0ID09PSBzaG9ydGN1dC50YXJnZXQpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzaG9ydGN1dC5hbGxvd0luLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuICFkaWZmZXJlbmNlKHRoaXMuX2lnbm9yZWQsIHNob3J0Y3V0LmFsbG93SW4pLmluY2x1ZGVzKHRhcmdldC5ub2RlTmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICF0aGlzLl9pZ25vcmVkLmluY2x1ZGVzKHRhcmdldC5ub2RlTmFtZSk7XG4gICAgfTtcblxuICAgIHByaXZhdGUgbWFwRXZlbnQgPSBldmVudCA9PlxuICAgICAgICB0aGlzLl9zaG9ydGN1dHNcbiAgICAgICAgICAgIC5tYXAoc2hvcnRjdXQgPT5cbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHt9LCBzaG9ydGN1dCwge1xuICAgICAgICAgICAgICAgICAgICBwcmVkaWNhdGVzOiBhbnkoXG4gICAgICAgICAgICAgICAgICAgICAgICBpZGVudGl0eSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNob3J0Y3V0LnByZWRpY2F0ZXMubWFwKChwcmVkaWNhdGVzOiBhbnkpID0+IGFsbFBhc3MocHJlZGljYXRlcykoZXZlbnQpKVxuICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICBldmVudDogZXZlbnRcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgLmZpbHRlcihzaG9ydGN1dCA9PiBzaG9ydGN1dC5wcmVkaWNhdGVzKVxuICAgICAgICAgICAgLnJlZHVjZSgoYWNjLCBzaG9ydGN1dCkgPT4gKGFjYy5wcmlvcml0eSA+IHNob3J0Y3V0LnByaW9yaXR5ID8gYWNjIDogc2hvcnRjdXQpLCB7XG4gICAgICAgICAgICAgICAgcHJpb3JpdHk6IDBcbiAgICAgICAgICAgIH0gYXMgUGFyc2VkU2hvcnRjdXQpO1xuXG4gICAgcHJpdmF0ZSBrZXlkb3duJCA9IGZyb21FdmVudChkb2N1bWVudCwgXCJrZXlkb3duXCIpLnBpcGUoXG4gICAgICAgIGZpbHRlcihfID0+ICF0aGlzLmRpc2FibGVkKSxcbiAgICAgICAgbWFwKHRoaXMubWFwRXZlbnQpLFxuICAgICAgICBmaWx0ZXIoXG4gICAgICAgICAgICAoc2hvcnRjdXQ6IFBhcnNlZFNob3J0Y3V0KSA9PlxuICAgICAgICAgICAgICAgICFzaG9ydGN1dC50YXJnZXQgfHwgc2hvcnRjdXQuZXZlbnQudGFyZ2V0ID09PSBzaG9ydGN1dC50YXJnZXRcbiAgICAgICAgKSxcbiAgICAgICAgZmlsdGVyKChzaG9ydGN1dDogUGFyc2VkU2hvcnRjdXQpID0+IGlzRnVuY3Rpb24oc2hvcnRjdXQuY29tbWFuZCkpLFxuICAgICAgICBmaWx0ZXIodGhpcy5pc0FsbG93ZWQpLFxuICAgICAgICB0YXAoc2hvcnRjdXQgPT4gIXNob3J0Y3V0LnByZXZlbnREZWZhdWx0IHx8IHNob3J0Y3V0LmV2ZW50LnByZXZlbnREZWZhdWx0KCkpLFxuICAgICAgICBkZWJvdW5jZShzaG9ydGN1dCA9PiB0aW1lcihzaG9ydGN1dC50aHJvdHRsZVRpbWUpKSxcbiAgICAgICAgdGFwKHNob3J0Y3V0ID0+IHNob3J0Y3V0LmNvbW1hbmQoeyBldmVudDogc2hvcnRjdXQuZXZlbnQsIGtleTogc2hvcnRjdXQua2V5IH0pKSxcbiAgICAgICAgdGFwKHNob3J0Y3V0ID0+IHRoaXMuX3ByZXNzZWQubmV4dCh7IGV2ZW50OiBzaG9ydGN1dC5ldmVudCwga2V5OiBzaG9ydGN1dC5rZXkgfSkpLFxuICAgICAgICBjYXRjaEVycm9yKGVycm9yID0+IHRocm93RXJyb3IoZXJyb3IpKVxuICAgICk7XG5cbiAgICBwcml2YXRlIGdldCBzaG9ydGN1dHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zaG9ydGN1dHM7XG4gICAgfVxuXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9uID0gdGhpcy5rZXlkb3duJC5zdWJzY3JpYmUoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgc3Vic2NyaXB0aW9uLlxuICAgICAqL1xuICAgIG5nT25EZXN0cm95KCk6IHZvaWQge1xuICAgICAgICBpZiAodGhpcy5zdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIHRoaXMuc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFbmFibGUgYWxsIGtleWJvYXJkIHNob3J0Y3V0c1xuICAgICAqL1xuICAgIGVuYWJsZSgpOiBLZXlib2FyZFNob3J0Y3V0c1NlcnZpY2Uge1xuICAgICAgICB0aGlzLmRpc2FibGVkID0gZmFsc2U7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERpc2FibGUgYWxsIGtleWJvYXJkIHNob3J0Y3V0c1xuICAgICAqL1xuICAgIGRpc2FibGUoKTogS2V5Ym9hcmRTaG9ydGN1dHNTZXJ2aWNlIHtcbiAgICAgICAgdGhpcy5kaXNhYmxlZCA9IHRydWU7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIGFsbCBrZXlib2FyZCBzaG9ydGN1dHMgYXJlIGRpc2FibGVkLlxuICAgICAqL1xuICAgIGlzRGlzYWJsZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRpc2FibGVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZCBuZXcgc2hvcnRjdXQvc1xuICAgICAqL1xuICAgIHB1YmxpYyBhZGQoc2hvcnRjdXRzOiBTaG9ydGN1dElucHV0W10gfCBTaG9ydGN1dElucHV0LCBpbnN0YW5jZT86IGFueSk6IEtleWJvYXJkU2hvcnRjdXRzU2VydmljZSB7XG4gICAgICAgIHNob3J0Y3V0cyA9IEFycmF5LmlzQXJyYXkoc2hvcnRjdXRzKSA/IHNob3J0Y3V0cyA6IFtzaG9ydGN1dHNdO1xuICAgICAgICBpZiAoaW5zdGFuY2UpIHtcbiAgICAgICAgICAgIGNvbnN0IFtrZXldID0gWy4uLnNob3J0Y3V0cy5tYXAoc2hvcnRjdXQgPT4gc2hvcnRjdXQua2V5KV07XG4gICAgICAgICAgICB0aGlzLmJpbmRPbkRlc3Ryb3koaW5zdGFuY2UsIGtleSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9zaG9ydGN1dHMucHVzaCguLi50aGlzLnBhcnNlQ29tbWFuZChzaG9ydGN1dHMpKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogYmluZCB0byB0aGUgY29tcG9uZW50IG5nT25EZXN0cm95IHRvIHJlbW92ZSByZWxhdGVkIGtleXNcbiAgICAgKiB3aGVuIGNvbXBvbmVudCBpcyBkZXN0cm95ZWQuXG4gICAgICogQHBhcmFtIGluc3RhbmNlIC0gY29tcG9uZW50IHRvIHJlbW92ZSBrZXlzIHdoZW4gbmdPbkRlc3Ryb3kgaXMgY2FsbGVkLlxuICAgICAqIEBwYXJhbSBrZXlzXG4gICAgICovXG4gICAgcHJpdmF0ZSBiaW5kT25EZXN0cm95KGluc3RhbmNlOiBhbnksIGtleXM6IHN0cmluZyB8IHN0cmluZ1tdKTogS2V5Ym9hcmRTaG9ydGN1dHNTZXJ2aWNlIHtcbiAgICAgICAgaWYgKGluc3RhbmNlLm5nT25EZXN0cm95KSB7XG4gICAgICAgICAgICBpbnN0YW5jZVskJG5nT25EZXN0cm95XSA9IGluc3RhbmNlLm5nT25EZXN0cm95O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRoYXQgPSB0aGlzO1xuICAgICAgICBpbnN0YW5jZS5uZ09uRGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgY29uc3Qgb25EZXN0cm95ID0gaW5zdGFuY2VbJCRuZ09uRGVzdHJveV07XG4gICAgICAgICAgICBpZiAob25EZXN0cm95KSB7XG4gICAgICAgICAgICAgICAgb25EZXN0cm95LmFwcGx5KHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhhdC5yZW1vdmUoa2V5cyk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZSBhIGNvbW1hbmQgYmFzZWQgb24ga2V5IG9yIGFycmF5IG9mIGtleXMuXG4gICAgICogY2FuIGJlIHVzZWQgZm9yIGNsZWFudXAuXG4gICAgICogQHBhcmFtIGtleVxuICAgICAqIEByZXR1cm5zXG4gICAgICovXG4gICAgcHVibGljIHJlbW92ZShrZXk6IHN0cmluZyB8IHN0cmluZ1tdKTogS2V5Ym9hcmRTaG9ydGN1dHNTZXJ2aWNlIHtcbiAgICAgICAgY29uc3Qga2V5czogc3RyaW5nW10gPSBBcnJheS5pc0FycmF5KGtleSkgPyBrZXkgOiBba2V5XTtcbiAgICAgICAgdGhpcy5fc2hvcnRjdXRzID0gdGhpcy5fc2hvcnRjdXRzLmZpbHRlcihzaG9ydGN1dCA9PiB7XG4gICAgICAgICAgICByZXR1cm4gIXNob3J0Y3V0LmtleS5maW5kKHNLZXkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBrZXlzLmZpbHRlcihrID0+IGsgPT09IHNLZXkpLmxlbmd0aCA+IDA7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYW4gb2JzZXJ2YWJsZSBvZiBrZXlib2FyZCBzaG9ydGN1dCBmaWx0ZXJlZCBieSBhIHNwZWNpZmljIGtleS5cbiAgICAgKiBAcGFyYW0ga2V5IC0gdGhlIGtleSB0byBmaWx0ZXIgdGhlIG9ic2VydmFibGUgYnkuXG4gICAgICovXG4gICAgcHVibGljIHNlbGVjdChrZXk6IHN0cmluZyk6IE9ic2VydmFibGU8U2hvcnRjdXRFdmVudE91dHB1dD4ge1xuICAgICAgICByZXR1cm4gdGhpcy5wcmVzc2VkJC5waXBlKFxuICAgICAgICAgICAgZmlsdGVyKCh7ZXZlbnQsIGtleTogZXZlbnRLZXlzfSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiAhIWV2ZW50S2V5cy5maW5kKGV2ZW50S2V5ID0+IGV2ZW50S2V5ID09PSBrZXkpXG4gICAgICAgICAgICB9KVxuICAgICAgICApXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogdHJhbnNmb3JtcyBhIHNob3J0Y3V0IHRvOlxuICAgICAqIGEgcHJlZGljYXRlIGZ1bmN0aW9uXG4gICAgICovXG4gICAgcHJpdmF0ZSBnZXRLZXlzID0gKGNvbW1hbmQ6IHN0cmluZ1tdKSA9PlxuICAgICAgICBjb21tYW5kXG4gICAgICAgICAgICAubWFwKGtleSA9PiBrZXkudHJpbSgpKVxuICAgICAgICAgICAgLmZpbHRlcihrZXkgPT4ga2V5ICE9PSBcIitcIilcbiAgICAgICAgICAgIC5tYXAoa2V5ID0+IHtcbiAgICAgICAgICAgICAgICAvLyBmb3IgbW9kaWZpZXJzIGxpa2UgY29udHJvbCBrZXlcbiAgICAgICAgICAgICAgICAvLyBsb29rIGZvciBldmVudFsnY3RybEtleSddXG4gICAgICAgICAgICAgICAgLy8gb3RoZXJ3aXNlIHVzZSB0aGUga2V5Q29kZVxuICAgICAgICAgICAgICAgIGlmIChtb2RpZmllcnMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXZlbnQgPT4gISFldmVudFttb2RpZmllcnNba2V5XV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBldmVudCA9PlxuICAgICAgICAgICAgICAgICAgICBjb2Rlc1trZXldXG4gICAgICAgICAgICAgICAgICAgICAgICA/IGV2ZW50LmtleUNvZGUgPT09IGNvZGVzW2tleV0gfHwgZXZlbnQua2V5ID09PSBrZXlcbiAgICAgICAgICAgICAgICAgICAgICAgIDogZXZlbnQua2V5Q29kZSA9PT0ga2V5LnRvVXBwZXJDYXNlKCkuY2hhckNvZGVBdCgwKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogUGFyc2UgZWFjaCBjb21tYW5kIHVzaW5nIGdldEtleXMgZnVuY3Rpb25cbiAgICAgKi9cbiAgICBwcml2YXRlIHBhcnNlQ29tbWFuZChjb21tYW5kOiBTaG9ydGN1dElucHV0IHwgU2hvcnRjdXRJbnB1dFtdKTogUGFyc2VkU2hvcnRjdXRbXSB7XG4gICAgICAgIGNvbnN0IGNvbW1hbmRzID0gQXJyYXkuaXNBcnJheShjb21tYW5kKSA/IGNvbW1hbmQgOiBbY29tbWFuZF07XG4gICAgICAgIHJldHVybiBjb21tYW5kcy5tYXAoY29tbWFuZCA9PiB7XG4gICAgICAgICAgICBjb25zdCBrZXlzID0gQXJyYXkuaXNBcnJheShjb21tYW5kLmtleSkgPyBjb21tYW5kLmtleSA6IFtjb21tYW5kLmtleV07XG4gICAgICAgICAgICBjb25zdCBwcmlvcml0eSA9IE1hdGgubWF4KC4uLmtleXMubWFwKGtleSA9PiBrZXkuc3BsaXQoXCIgXCIpLmxlbmd0aCkpO1xuICAgICAgICAgICAgY29uc3QgcHJlZGljYXRlcyA9IGtleXMubWFwKGtleSA9PiB0aGlzLmdldEtleXMoa2V5LnNwbGl0KFwiIFwiKSkpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAuLi5jb21tYW5kLFxuICAgICAgICAgICAgICAgIGFsbG93SW46IGNvbW1hbmQuYWxsb3dJbiB8fCBbXSxcbiAgICAgICAgICAgICAgICBrZXk6IGtleXMsXG4gICAgICAgICAgICAgICAgdGhyb3R0bGU6IGlzTmlsbChjb21tYW5kLnRocm90dGxlVGltZSkgPyB0aGlzLnRocm90dGxlVGltZSA6IGNvbW1hbmQudGhyb3R0bGVUaW1lLFxuICAgICAgICAgICAgICAgIHByaW9yaXR5OiBwcmlvcml0eSxcbiAgICAgICAgICAgICAgICBwcmVkaWNhdGVzOiBwcmVkaWNhdGVzXG4gICAgICAgICAgICB9IGFzIFBhcnNlZFNob3J0Y3V0O1xuICAgICAgICB9KTtcbiAgICB9XG59XG4iXX0=